<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Atomic Shape Studio — Single Grid System</title>
<style>
  :root{
    --bg:#f7f9fc; --panel:#ffffff; --panel-2:#f1f4f8;
    --ink:#0b1526; --ink-2:#55637a; --accent:#1c6ef2;
    --ok:#059669; --warn:#b45309; --err:#e11d48;
    --grid:#e3e8f0; --grid-strong:#cbd5e1; --cell-border:#b6c2d0;
    --sel:#c68400; --hover:#2563eb; --contact:#fb923c; --contact2:#10b981;
    --ghost:#93c5fd55; --ghost-line:#60a5fa; --invalid:#fecaca88; --invalid-line:#f87171;
  }
  html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);font:14px/1.35 system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif}
  #app{
    height:100%; display:grid; min-width:0; min-height:0;
    grid-template-columns:300px 1fr 380px;
    grid-template-rows:auto 1fr auto;
    grid-template-areas:
      "header header header"
      "left   main   right"
      "footer footer footer";
  }
  header{grid-area:header;display:flex;align-items:center;gap:12px;padding:10px 14px;background:var(--panel-2);border-bottom:1px solid #e5eaf1}
  header h1{font-size:16px;margin:0;font-weight:700}
  #left{grid-area:left;background:var(--panel);border-right:1px solid #e5eaf1;overflow:auto;min-width:0}
  #right{grid-area:right;background:var(--panel);border-left:1px solid #e5eaf1;overflow:auto;min-width:0}
  footer{grid-area:footer;padding:8px 12px;background:var(--panel-2);border-top:1px solid #e5eaf1;color:var(--ink-2);display:flex;justify-content:space-between;gap:12px;white-space:nowrap;overflow:auto}
  #main{grid-area:main;position:relative;min-width:0;min-height:0;background:#f8fbff;overflow:hidden}
  #canvas{position:absolute;inset:0;width:100%;height:100%;display:block}

  .toolbar{
    position:absolute; left:8px; top:8px; right:8px; z-index:2;
    display:flex; gap:8px; align-items:center; flex-wrap:wrap;
    background:#ffffffd6; border:1px solid #e2e8f0; border-radius:10px; padding:8px; backdrop-filter:blur(6px)
  }
  .toolbtn input{display:none}
  .toolbtn label{display:inline-block;padding:6px 10px;border:1px solid #d0d7e2;border-radius:8px;cursor:pointer;background:#f3f6fb;color:var(--ink);user-select:none}
  .toolbtn input:checked + label{background:#1c6ef2;color:#fff;border-color:#1658be}
  .sep{width:1px;height:24px;background:#e2e8f0;margin:0 4px}
  .pill{display:inline-flex;align-items:center;gap:6px;padding:2px 8px;border:1px solid #d0d7e2;border-radius:999px;background:#f3f6fb}

  .section{padding:12px 14px;border-bottom:1px solid #e5eaf1}
  .section h2{margin:0 0 8px;font-size:13px;color:#0b1526;font-weight:700}
  .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .col{display:flex;flex-direction:column;gap:6px}
  .muted{color:var(--ink-2)}
  .kv{display:grid;grid-template-columns:140px 1fr;gap:6px;align-items:center}
  .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,"Liberation Mono",monospace}
  label{font-size:12px;color:var(--ink-2)}
  input[type="text"],input[type="number"],select,textarea{
    background:#fff;border:1px solid #d7dde7;color:var(--ink);border-radius:6px;padding:8px 10px;font-size:13px;outline:none;min-width:0
  }
  input[type="number"]{width:100px}
  button{background:#f3f6fb;border:1px solid #d0d7e2;color:var(--ink);border-radius:8px;padding:8px 10px;font-size:13px;cursor:pointer;user-select:none;transition:.12s;white-space:nowrap}
  button:hover{border-color:#b8c2d3;background:#e9eef7}
  button.primary{background:#1c6ef2;color:#fff;border-color:#1658be}
  button.good{background:#059669;color:#fff;border-color:#047857}
  button.ghost{background:#fff;border-color:#d0d7e2}
  .list{display:flex;flex-direction:column;border:1px solid #e5eaf1;border-radius:10px;overflow:hidden}
  .list .item{display:flex;justify-content:space-between;gap:8px;padding:8px 10px;border-top:1px solid #e5eaf1;background:#fff}
  .list .item:first-child{border-top:none}
  .status{padding:8px 10px;border-radius:10px;border:1px solid #e2e8f0;background:#fff}
  .ok{border-color:#bbf7d0;background:#f0fdf4}
  .warn{border-color:#fde68a;background:#fffbeb}
  .err{border-color:#fecdd3;background:#fff1f2}
  .contactItem{padding:6px 8px;border:1px solid #e2e8f0;border-radius:8px;background:#fafcff;margin-bottom:6px}
</style>
</head>
<body>
<div id="app">
  <header>
    <h1>Atomic Shape Studio</h1>
    <div class="muted">Single grid: cells 1-based; gridlines 0-based. Contacts sit on gridlines. All math goes through the grid helpers.</div>
  </header>

  <aside id="left">
    <div class="section">
      <h2>Atomic Palette</h2>
      <div class="row">
        <div class="col">
          <label>Identifier</label>
          <input id="atomId" type="text" placeholder="R1" value="R1">
        </div>
        <div class="col">
          <label>Height H</label>
          <input id="atomH" type="number" min="1" step="1" value="3">
        </div>
        <div class="col">
          <label>Width W</label>
          <input id="atomW" type="number" min="1" step="1" value="4">
        </div>
        <button id="addAtom" class="primary">Add / Update</button>
      </div>
      <div class="section" style="padding:10px 0 0 0;border:none">
        <div class="list" id="atomList"></div>
      </div>
      <div class="row" style="padding:8px 14px">
        <button id="placeFirst" class="good">Place Selected</button>
        <button id="clearPalette" class="ghost">Clear Palette</button>
      </div>
    </div>

    <div class="section">
      <h2>Grid</h2>
      <div class="row">
        <label>Cell size</label>
        <input id="cellSize" type="number" min="16" max="96" step="2" value="48" style="width:90px">
        <label>Bold every 5</label>
        <input id="boldGrid" type="checkbox" checked>
      </div>
    </div>

    <div class="section">
      <h2>ID Consolidation</h2>
      <div class="muted">Re-numbers atoms (R…), composites (C…), instances (Q…) sequentially.</div>
      <div class="row" style="margin-top:8px">
        <button id="consolidateIds" class="good">Consolidate IDs</button>
        <button id="resetConsolidation" class="ghost">Reset Maps</button>
      </div>
      <div id="consolidationStats" class="status mono" style="margin-top:8px; display:none;"></div>
      <div class="row" style="margin-top:8px">
        <button id="copyConsolidation" class="ghost">Copy stats</button>
      </div>
    </div>
  </aside>

  <main id="main">
    <canvas id="canvas"></canvas>
    <div class="toolbar">
      <div class="toolbtn">
        <input type="radio" name="tool" id="toolSelect" checked>
        <label for="toolSelect">Select/Move</label>
      </div>
      <div class="toolbtn">
        <input type="radio" name="tool" id="toolDraw">
        <label for="toolDraw">Draw Rectangle</label>
      </div>
      <div class="sep"></div>
      <button id="undoBtn" class="ghost" title="Ctrl+Z">Undo</button>
      <button id="redoBtn" class="ghost" title="Ctrl+Y">Redo</button>
      <div class="sep"></div>
      <span class="pill">Hover: <span id="hoverLabel" class="mono">—</span></span>
      <span class="pill">Selected: <span id="selBadge" class="mono">—</span></span>
      <button id="bringFront" class="ghost">Bring to Front</button>
      <button id="sendBack" class="ghost">Send to Back</button>
    </div>
  </main>

  <aside id="right">
    <div class="section">
      <h2>Selection</h2>
      <div id="selStatus" class="status">No selection</div>
      <div class="kv" style="margin-top:8px">
        <div>Label</div><div class="mono" id="selLabel">—</div>
        <div>Dims (H×W)</div><div class="mono" id="selDims">—</div>
        <div>Pos (dy,dx)</div><div class="mono" id="selPos">—</div>
        <div>Canonical</div><div class="mono" id="selCanon">—</div>
        <div>Notation</div><div class="mono" id="selNotation">—</div>
      </div>
      <div class="row" style="margin-top:8px">
        <button id="copySelection" class="ghost">Copy Selection</button>
      </div>
      <div class="row" style="margin-top:10px">
        <button id="toggleHat">Toggle ^</button>
        <button id="duplicate">Duplicate</button>
        <button id="deleteSel">Delete</button>
      </div>
    </div>

    <div class="section">
      <h2>Resize / Re-shape</h2>
      <div class="muted">Handles or numeric edits. “Apply to all” changes the base atom.</div>
      <div class="row" style="margin-top:8px">
        <div class="col"><label>H (used)</label><input id="editH" type="number" min="1" step="1" value="1"></div>
        <div class="col"><label>W (used)</label><input id="editW" type="number" min="1" step="1" value="1"></div>
        <div class="col"><label>dy</label><input id="editDY" type="number" step="1" value="1"></div>
        <div class="col"><label>dx</label><input id="editDX" type="number" step="1" value="1"></div>
      </div>
      <div class="row" style="margin-top:6px">
        <input id="applyAll" type="checkbox"><label for="applyAll">Apply to all with same ID</label>
      </div>
      <div class="row" style="margin-top:6px">
        <button id="applyNumeric" class="primary">Apply</button>
        <button id="detachNow" class="ghost">Detach as new ID</button>
      </div>
    </div>

    <div class="section">
      <h2>Contacts</h2>
      <div class="row" style="margin-bottom:8px">
        <button id="copyContacts" class="ghost">Copy Contacts</button>
      </div>
      <div id="contactList"></div>
    </div>

    <div class="section">
      <h2>Scene</h2>
      <div class="kv">
        <div>Placements</div><div class="mono" id="countP">0</div>
        <div>Occupied cells</div><div class="mono" id="countC">0</div>
      </div>
      <div class="row" style="margin-top:8px">
        <button id="copyScene" class="ghost">Copy Scene</button>
        <button id="copyAllObjects" class="ghost">Copy All Objects</button>
      </div>
      <div class="row" style="margin-top:8px">
        <button id="exportSVG" class="primary">Export SVG</button>
        <button id="exportNotation" class="primary">Export Notation</button>
      </div>
      <div class="row" style="margin-top:8px">
        <input type="file" id="importFile" accept=".txt" style="display:none">
        <button id="importNotation" class="primary">Import Notation</button>
      </div>
      <div class="row" style="margin-top:8px">
        <button id="resetScene" class="ghost">Reset</button>
        <button id="fitView" class="ghost">Center First</button>
      </div>
    </div>

    <div class="section">
      <h2>Help</h2>
      <div class="muted">
        - X = top edge, Y = right edge, -X = bottom edge, -Y = left edge (object-local).<br>
        - Canonical atoms have W ≥ H. '^' is vertical orientation of a non-square atom.<br>
        - No overlap. When shapes touch, orange lines and exact edge-run notation use the same gridlines the canvas draws.
      </div>
    </div>
  </aside>

  <footer>
    <div>- Pointer: select/move, resize handles, rotate knob (non-square). - Keys: R toggle ^, Del delete, Ctrl+Z/Y undo/redo</div>
    <div class="muted">Cells are 1-based; gridlines are 0-based.</div>
  </footer>
</div>

<script>
'use strict';

/* ===================== Grid (single source of truth) ===================== */
/* Cells are 1-based (1..∞). Gridlines are 0-based (…0,1,2…). The left/bottom
   canvas edges are gridline 0. A cell (y,x) spans x:[x-1,x], y:[y-1,y] in gridlines. */
const grid = {
  g: 48,
  get w(){ return canvas.width / (window.devicePixelRatio||1); },
  get h(){ return canvas.height / (window.devicePixelRatio||1); },

  // gridlines → pixels
  lineX(gx){ return gx * this.g; },                      // vertical line gx
  lineY(gy){ return this.h - gy * this.g; },             // horizontal line gy

  // cells → pixels (top-left of a cell)
  cellLeft(x){ return this.lineX(x-1); },                // left boundary of cell x
  cellTop(y){ return this.lineY(y); },                   // top boundary of cell y

  // pixels → cells (1-based)
  cellX(px){ return Math.floor(px / this.g) + 1; },
  cellY(py){ return Math.floor((this.h - py) / this.g) + 1; }
};

const DEBUG=false;

/* ===================== Utilities ===================== */
const byId = (id) => document.getElementById(id);
const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
const uidSeq = (prefix, existing) => {
  let max = 0;
  for(const id of existing){
    const m = id.match(new RegExp(`^${prefix}(\\d+)$`));
    if(m) max = Math.max(max, parseInt(m[1],10));
  }
  return `${prefix}${max+1||1}`;
};

let _hue = Math.floor(Math.random()*360);
function nextColor(){
  _hue = (_hue + 137.508) % 360; // golden angle
  return `hsl(${_hue}, 68%, 62%)`;
}
function getStrokeForFill(hsl){
  const m = hsl.match(/hsl\(([-\d.]+),\s*([\d.]+)%\s*,\s*([\d.]+)%\s*\)/);
  if(!m) return '#b6c2d0';
  const h=+m[1], s=+m[2], l=Math.max(20, +m[3]-12);
  return `hsl(${h}, ${s}%, ${l}%)`;
}

function generateCompositeName(){
  return 'S' + (State.compositeNameCounter++);
}

/* ===================== Data Model ===================== */
class Atomic {
  constructor(id,H,W){
    if(!Number.isInteger(H)||!Number.isInteger(W)||H<=0||W<=0) throw new Error("H and W must be positive integers.");
    if(W < H){ const t=W; W=H; H=t; } // canonical W ≥ H
    this.id=id; this.H=H; this.W=W;
  }
  dims(){ return [this.H,this.W]; }
  toString(){ return `< ${this.id} | 1,1 ; ${this.H},${this.W} >`; }
}
class Registry {
  constructor(){ this.map=new Map(); }
  _canonicalId(H,W,prefix="R"){
    const key = `${H},${W}`;
    if(ID_CONSOLIDATION.dimensionMap.has(key)) return ID_CONSOLIDATION.dimensionMap.get(key);
    const ids = [...this.map.keys()].filter(k=>k.startsWith(prefix));
    const newId = uidSeq(prefix, ids);
    ID_CONSOLIDATION.dimensionMap.set(key, newId);
    return newId;
  }
  add(atom){
    const id = this._canonicalId(atom.H, atom.W);
    const existing = this.map.get(id);
    if(existing && (existing.H!==atom.H || existing.W!==atom.W)) throw new Error(`Duplicate id '${id}' with conflicting dims.`);
    atom.id = id;
    this.map.set(id, atom);
  }
  update(id,H,W){
    if(W < H){ const t=W; W=H; H=t; }
    const newId = this._canonicalId(H,W);
    if(newId!==id){
      const newAtom = new Atomic(newId,H,W);
      this.map.delete(id); this.map.set(newId,newAtom);
      for(const p of State.placements) if(p.baseId===id) p.baseId=newId;
    }else{
      const a = this.map.get(id); if(!a) throw new Error(`Unknown atomic id: ${id}`); a.H=H; a.W=W;
    }
  }
  get(id){ const a=this.map.get(id); if(!a) throw new Error(`Unknown atomic id: ${id}`); return a; }
  list(){ return [...this.map.values()]; }
  clear(){ this.map.clear(); }
}
class Placement {
  constructor({baseId, vshift=[1,1], vertical=false, color=null}){
    this.uid = generatePlacementId();
    this.baseId = baseId;
    this.vshift = [...vshift]; // [dy,dx] bottom-left cell of rect
    this.vertical = !!vertical;
    this.tempDims = null;
    this.color = color || nextColor();
  }
  usedDims(reg){
    if(this.tempDims) return this.tempDims;
    const [H,W] = reg.get(this.baseId).dims();
    if(H===W) return [H,W];
    return this.vertical ? [W,H] : [H,W];
  }
  rect(reg){
    const [H,W] = this.usedDims(reg);
    const [dy,dx] = this.vshift;
    return { y1:dy, x1:dx, y2:dy+H-1, x2:dx+W-1, H, W, dy, dx };
  }
}

/* ===================== State & History ===================== */
const State = {
  reg: new Registry(),
  placements: [],
  selected: null,
  hovered: null,
  hoveringRotate: false,
  tool: "select",
  drawDrag: null,
  resizeDrag: null,
  contacts: [],
  compositeObjects: new Map(),
  compositeNameCounter: 1,
  lastPlacementSig: '',
  history: [],
  future: [],
  _raf: null
};

function snapshot(){
  return JSON.stringify({
    reg: State.reg.list().map(a=>({id:a.id,H:a.H,W:a.W})),
    placements: State.placements.map(p=>({uid:p.uid,baseId:p.baseId,vshift:p.vshift,vertical:p.vertical,color:p.color,tempDims:p.tempDims})),
    selected: State.selected,
    hovered: State.hovered,
    cell: grid.g,
    bold5: byId('boldGrid').checked
  });
}
function restore(snap){
  const o = JSON.parse(snap);
  State.reg.clear();
  for(const a of o.reg) State.reg.add(new Atomic(a.id,a.H,a.W));
  State.placements = o.placements.map(pp=>{ const p=new Placement({baseId:pp.baseId,vshift:pp.vshift,vertical:pp.vertical,color:pp.color}); p.uid=pp.uid; p.tempDims=pp.tempDims; return p; });
  State.selected=o.selected; State.hovered=o.hovered; grid.g=o.cell; byId('cellSize').value=o.cell; byId('boldGrid').checked=o.bold5;
  refreshPalette(); updateRightPanel(); scheduleDraw();
}
function pushHistory(){
  State.history.push(snapshot());
  if(State.history.length>200) State.history.shift();
  State.future.length=0;
}
function undo(){ if(State.history.length===0) return; const cur=snapshot(); const prev=State.history.pop(); State.future.push(cur); restore(prev); }
function redo(){ if(State.future.length===0) return; const cur=snapshot(); const next=State.future.pop(); State.history.push(cur); restore(next); }

/* ===================== Consolidation Maps ===================== */
const ID_CONSOLIDATION = {
  dimensionMap: new Map(),
  reset(){ this.dimensionMap.clear(); },
  consolidateAll(){
    const stats = { atomicConsolidated:0, placementConsolidated:0, compositeConsolidated:0 };

    // keep only used atomics and renumber
    const used = new Set(State.placements.map(p=>p.baseId));
    const newMap = new Map(); const mapping = new Map(); let k=1;
    for(const id of used){ const a=State.reg.get(id); const nid=`R${k++}`; newMap.set(nid, new Atomic(nid,a.H,a.W)); mapping.set(id,nid); stats.atomicConsolidated++; }
    State.reg.map = newMap;
    for(const p of State.placements) if(mapping.has(p.baseId)) p.baseId = mapping.get(p.baseId);

    // placements renumber
    const ids = State.placements.map(p=>p.uid);
    const mapP = new Map(); let q=1; for(const id of ids){ mapP.set(id, `Q${q++}`); }
    for(const p of State.placements){ p.uid = mapP.get(p.uid); stats.placementConsolidated++; }
    // remap interaction state
    State.selected = mapP.get(State.selected) ?? null;
    State.hovered = mapP.get(State.hovered) ?? null;
    if(State.resizeDrag && State.resizeDrag.uid){
      const nu = mapP.get(State.resizeDrag.uid) ?? null;
      if(nu) State.resizeDrag.uid = nu; else State.resizeDrag = null;
    }
    if(window.draggingMove && draggingMove?.uid){
      const nu = mapP.get(draggingMove.uid) ?? null;
      if(nu) draggingMove.uid = nu; else draggingMove = null;
    }

    // composites re-label with sequential ids and names; advance counter
    const compNew = new Map(); let c=1;
    for(const [, info] of State.compositeObjects){
      const id = `C${c}`; const name = `S${c}`;
      compNew.set(id, { ...info, id, name, color: generateCompositeColor(id) });
      c++; stats.compositeConsolidated++;
    }
    State.compositeObjects = compNew;
    State.compositeNameCounter = c;

    this.reset();
    // Post-consolidation UI refresh and history
    refreshPalette(); updateRightPanel(); scheduleDraw(); pushHistory();
    return stats;
  }
};
function generatePlacementId(){ return uidSeq("Q", State.placements.map(p=>p.uid)); }

/* ===================== Canvas & Drawing ===================== */
const canvas = byId('canvas');
const ctx = canvas.getContext('2d', {alpha:false});

function resizeCanvas(){
  const host = byId('main');
  const r = host.getBoundingClientRect();
  const dpr = window.devicePixelRatio || 1;
  const w = Math.max(1, Math.ceil(r.width * dpr));
  const h = Math.max(1, Math.ceil(r.height * dpr));
  canvas.width = w; canvas.height = h; ctx.setTransform(dpr,0,0,dpr,0,0);
  scheduleDraw();
}
new ResizeObserver(resizeCanvas).observe(byId('main'));
window.addEventListener('resize', resizeCanvas);

function scheduleDraw(){
  if(State._raf) return;
  State._raf = requestAnimationFrame(()=>{ State._raf=null; draw(); });
}

function drawGrid(){
  const g = grid.g, w = grid.w, h = grid.h;

  ctx.save();
  ctx.fillStyle = '#f8fbff'; ctx.fillRect(0,0,w,h);

  // axes on gridline 0
  ctx.strokeStyle = '#1c6ef2'; ctx.lineWidth = 3;
  ctx.beginPath(); ctx.moveTo(grid.lineX(0), grid.lineY(0)); ctx.lineTo(w, grid.lineY(0));
  ctx.moveTo(grid.lineX(0), grid.lineY(0)); ctx.lineTo(grid.lineX(0), 0); ctx.stroke();
  ctx.fillStyle = '#1c6ef2'; ctx.font = 'bold 12px ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace';
  ctx.fillText('gridline (0,0)', 8, h-8);

  // gridlines (every cell)
  ctx.strokeStyle = '#e3e8f0'; ctx.lineWidth = 1; ctx.beginPath();
  const cols = Math.floor(w/g), rows = Math.floor(h/g);
  for(let gx=0; gx<=cols; gx++){ const x = grid.lineX(gx); ctx.moveTo(x,0); ctx.lineTo(x,h); }
  for(let gy=0; gy<=rows; gy++){ const y = grid.lineY(gy); ctx.moveTo(0,y); ctx.lineTo(w,y); }
  ctx.stroke();

  if(byId('boldGrid').checked){
    ctx.strokeStyle = '#cbd5e1'; ctx.lineWidth = 1.25; ctx.beginPath();
    for(let gx=0; gx<=cols; gx+=5){ const x=grid.lineX(gx); ctx.moveTo(x,0); ctx.lineTo(x,h); }
    for(let gy=0; gy<=rows; gy+=5){ const y=grid.lineY(gy); ctx.moveTo(0,y); ctx.lineTo(w,y); }
    ctx.stroke();

    // cell labels every 5
    ctx.fillStyle = '#55637a'; ctx.font = '10px ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace';
    ctx.textAlign='center'; ctx.textBaseline='bottom';
    for(let x=5; x<=cols; x+=5){ ctx.fillText(String(x+1), grid.cellLeft(x+1), h-2); }
    ctx.textAlign='left'; ctx.textBaseline='middle';
    for(let y=5; y<=rows; y+=5){ ctx.fillText(String(y+1), 4, grid.cellTop(y)+grid.g/2); }
  }

  // emphasise cell (1,1)
  ctx.fillStyle='#000'; ctx.fillRect(grid.cellLeft(1), grid.cellTop(1), g, g);
  ctx.strokeStyle='#fff'; ctx.lineWidth=2; ctx.strokeRect(grid.cellLeft(1), grid.cellTop(1), g, g);
  ctx.fillStyle='#fff'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText('1,1', grid.cellLeft(1)+g/2, grid.cellTop(1)+g/2);
  ctx.restore();
}

function drawPlacement(p, drawHandles=false){
  const r = p.rect(State.reg);
  const g = grid.g;

  // top-left of rect
  const x0 = grid.cellLeft(r.x1);
  const y0 = grid.cellTop(r.y1 + r.H - 1);

  // fill cells + inner borders
  for(let yy=0; yy<r.H; yy++){
    for(let xx=0; xx<r.W; xx++){
      const sx = x0 + xx*g, sy = y0 + yy*g;
      ctx.fillStyle = p.color; ctx.fillRect(sx, sy, g, g);
      ctx.strokeStyle = getStrokeForFill(p.color); ctx.lineWidth = 1; ctx.strokeRect(sx, sy, g, g);
    }
  }

  const isSel = (State.selected === p.uid), isHover = (State.hovered === p.uid);
  ctx.lineWidth = isSel ? 2 : 1.5;
  ctx.strokeStyle = isSel ? '#c68400' : isHover ? '#2563eb' : '#8ca2c0';
  ctx.strokeRect(x0, y0, r.W*g, r.H*g);

  // label
  ctx.fillStyle = '#0b1526'; ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace';
  ctx.fillText(`${p.vertical ? '^ ' : ''}${p.baseId} [${p.uid}]`, x0+4, y0+14);

  if(drawHandles && isSel){
    drawResizeHandles(x0,y0,r.W,r.H,g);
    const [H,W] = p.usedDims(State.reg);
    if(H !== W) drawRotateHandle(x0,y0,r.W,g, State.hoveringRotate);
  }
}
function drawResizeHandles(x0,y0,W,H,g){
  const r = Math.max(4, Math.min(8, Math.floor(g*0.18)));
  const pts = handlePoints(x0,y0,W,H,g);
  ctx.fillStyle = '#f59e0b'; ctx.strokeStyle = '#ffffff'; ctx.lineWidth = 1;
  for(const [px,py] of pts){ ctx.beginPath(); ctx.arc(px,py,r,0,Math.PI*2); ctx.fill(); ctx.stroke(); }
}
function drawRotateHandle(x0,y0,W,g,highlight=false){
  const xm = x0 + (W*g)/2;
  const y = y0 - Math.min(18, Math.max(12, g*0.35));
  const radius = Math.max(8, Math.min(12, Math.floor(g*0.25)));
  ctx.strokeStyle = highlight ? '#3b82f6' : '#9ca3af'; ctx.lineWidth = highlight ? 3 : 2;
  ctx.beginPath(); ctx.moveTo(xm, y0); ctx.lineTo(xm, y); ctx.stroke();
  ctx.fillStyle = highlight ? '#3b82f6' : '#1c6ef2';
  ctx.beginPath(); ctx.arc(xm, y, radius, 0, Math.PI*2); ctx.fill();
  ctx.strokeStyle = '#ffffff'; ctx.lineWidth = highlight ? 3 : 2; ctx.stroke();
  ctx.fillStyle = '#ffffff'; ctx.font = 'bold 10px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
  ctx.fillText('↻', xm, y);
}
function handlePoints(x0,y0,W,H,g){
  const xm = x0 + (W*g)/2, ym = y0 + (H*g)/2, x1 = x0 + W*g, y1 = y0 + H*g;
  return [[x0,y0],[xm,y0],[x1,y0],[x1,ym],[x1,y1],[xm,y1],[x0,y1],[x0,ym]];
}

function drawGhostRect(y1,x1,y2,x2, valid=true){
  const g = grid.g;
  const H=Math.abs(y2-y1)+1, W=Math.abs(x2-x1)+1, Y1=Math.min(y1,y2), X1=Math.min(x1,x2);
  const x0 = grid.cellLeft(X1);
  const y0 = grid.cellTop(Y1 + H - 1);
  ctx.save(); ctx.fillStyle = valid ? '#93c5fd55' : '#fecaca88'; ctx.strokeStyle = valid ? '#60a5fa' : '#f87171'; ctx.lineWidth = 2;
  ctx.fillRect(x0,y0, W*g, H*g); ctx.strokeRect(x0,y0, W*g, H*g); ctx.restore();
}

function drawContacts(){
  ctx.save(); ctx.lineWidth = 3; ctx.strokeStyle = '#fb923c';
  for(const c of State.contacts){
    if(c.kind === 'h'){
      // horizontal segment along gridline gy from x1-1 → x2
      const y = grid.lineY(c.gy);
      const xL = grid.lineX(c.x1 - 1);
      const xR = grid.lineX(c.x2);
      ctx.beginPath(); ctx.moveTo(xL, y); ctx.lineTo(xR, y); ctx.stroke();
    }else{
      // vertical segment along gridline gx from y1-1 → y2
      const x = grid.lineX(c.gx);
      const yTop = grid.lineY(c.y2);
      const yBot = grid.lineY(c.y1 - 1);
      ctx.beginPath(); ctx.moveTo(x, yTop); ctx.lineTo(x, yBot); ctx.stroke();
    }
  }
  ctx.restore();
}

function drawCompositeObjects(){
  const g = grid.g;
  for (const [, composite] of State.compositeObjects) {
    const { bounds, name, id, group, color } = composite;
    const x0 = grid.cellLeft(bounds.minX);
    const y0 = grid.cellTop(bounds.maxY);
    const width = (bounds.maxX - bounds.minX + 1)*g;
    const height= (bounds.maxY - bounds.minY + 1)*g;

    // dashed bounding box
    ctx.strokeStyle = color; ctx.lineWidth = 1.5; ctx.setLineDash([6,3]); ctx.strokeRect(x0, y0, width, height); ctx.setLineDash([]);
    // perimeter
    drawCompositePerimeter(group, g, color);
    // name (centered), guard if missing
    const label = (name ?? id);
    ctx.fillStyle = color; ctx.font = 'bold 14px ui-monospace, SFMono-Regular, Menlo, Consolas, Liberation Mono, monospace';
    ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText(label, x0 + width/2, y0 + height/2);
  }
}
function drawCompositePerimeter(group, g, color){
  const occ = new Set();
  for(const p of group){ const r=p.rect(State.reg); for(let y=r.y1;y<=r.y2;y++){ for(let x=r.x1;x<=r.x2;x++){ occ.add(`${y},${x}`); } } }
  ctx.strokeStyle = color; ctx.lineWidth = 4; ctx.setLineDash([]);
  for(const p of group){
    const r = p.rect(State.reg);
    for(let y=r.y1;y<=r.y2;y++){
      for(let x=r.x1;x<=r.x2;x++){
        const xL = grid.cellLeft(x), yT = grid.cellTop(y), yB = yT + g, xR = xL + g;
        // top
        if(!occ.has(`${y+1},${x}`)){ ctx.beginPath(); ctx.moveTo(xL, yT); ctx.lineTo(xR, yT); ctx.stroke(); }
        // right
        if(!occ.has(`${y},${x+1}`)){ ctx.beginPath(); ctx.moveTo(xR, yT); ctx.lineTo(xR, yB); ctx.stroke(); }
        // bottom
        if(!occ.has(`${y-1},${x}`)){ ctx.beginPath(); ctx.moveTo(xL, yB); ctx.lineTo(xR, yB); ctx.stroke(); }
        // left
        if(!occ.has(`${y},${x-1}`)){ ctx.beginPath(); ctx.moveTo(xL, yT); ctx.lineTo(xL, yB); ctx.stroke(); }
      }
    }
  }
}

function draw(){
  drawGrid();
  for(const p of State.placements){ drawPlacement(p, true); }
  if(State.drawDrag) drawGhostRect(State.drawDrag.y1, State.drawDrag.x1, State.drawDrag.y2, State.drawDrag.x2, State.drawDrag.valid!==false);
  computeContacts();
  drawContacts();
  updateCompositeObjects();
  drawCompositeObjects();
}

/* ===================== Geometry & Rules ===================== */
function rectsOverlap(a,b){ return !(a.x2 < b.x1 || a.x1 > b.x2 || a.y2 < b.y1 || a.y1 > b.y2); }
function wouldOverlap(candidate, excludeUid=null){
  for(const p of State.placements){
    if(p.uid===excludeUid) continue;
    if(rectsOverlap(candidate, p.rect(State.reg))) return true;
  }
  return false;
}

/* ===== Contacts (now on gridlines) =====
   - 'h': contact on horizontal gridline gy, spanning columns x1..x2 inclusive
           → draw from x=(x1-1) to x=x2 at line y=gy
   - 'v': contact on vertical gridline gx, spanning rows y1..y2 inclusive
           → draw from y=(y1-1) to y=y2 at line x=gx
*/
function computeContacts(){
  const res=[];
  for(let i=0;i<State.placements.length;i++){
    for(let j=i+1;j<State.placements.length;j++){
      const A = State.placements[i], B = State.placements[j];
      const a = A.rect(State.reg), b = B.rect(State.reg);

      // horizontal adjacency
      if(a.y2 + 1 === b.y1){
        const x1 = Math.max(a.x1,b.x1), x2 = Math.min(a.x2,b.x2);
        if(x1<=x2) res.push(contactRecord(A,B, 'h', /*gy*/ a.y2, x1, x2));
      }
      if(b.y2 + 1 === a.y1){
        const x1 = Math.max(a.x1,b.x1), x2 = Math.min(a.x2,b.x2);
        if(x1<=x2) res.push(contactRecord(A,B, 'h', /*gy*/ b.y2, x1, x2));
      }

      // vertical adjacency
      if(a.x2 + 1 === b.x1){
        const y1 = Math.max(a.y1,b.y1), y2 = Math.min(a.y2,b.y2);
        if(y1<=y2) res.push(contactRecord(A,B, 'v', /*gx*/ a.x2, y1, y2));
      }
      if(b.x2 + 1 === a.x1){
        const y1 = Math.max(a.y1,b.y1), y2 = Math.min(a.y2,b.y2);
        if(y1<=y2) res.push(contactRecord(A,B, 'v', /*gx*/ b.x2, y1, y2));
      }
    }
  }
  State.contacts = res;
  updateContactPanel();
}

function contactRecord(A,B, kind, fixed, c1, c2){
  const a = A.rect(State.reg), b = B.rect(State.reg);

  function runForRect(P, R){
    if(kind==='h'){
      // fixed is gy; if gy==R.y2 → top edge (X); if gy==R.y1-1 → bottom (-X)
      const edge = (fixed === R.y2) ? 'X' : (fixed === R.y1-1) ? '-X' : '?';
      const yLocal = (edge==='X') ? R.H : 1;
      const xl1 = Math.max(c1, R.x1) - R.x1 + 1;
      const xl2 = Math.min(c2, R.x2) - R.x1 + 1;
      return { id:P.baseId, hat:P.vertical, edge, y1:yLocal, x1:xl1, y2:yLocal, x2:xl2 };
    }else{
      // fixed is gx; if gx==R.x2 → right edge (Y); if gx==R.x1-1 → left (-Y)
      const edge = (fixed === R.x2) ? 'Y' : (fixed === R.x1-1) ? '-Y' : '?';
      const xLocal = (edge==='Y') ? R.W : 1;
      const yl1 = Math.max(c1, R.y1) - R.y1 + 1;
      const yl2 = Math.min(c2, R.y2) - R.y1 + 1;
      return { id:P.baseId, hat:P.vertical, edge, y1:yl1, x1:xLocal, y2:yl2, x2:xLocal };
    }
  }
  return (kind==='h')
    ? { kind:'h', gy:fixed, x1:c1, x2:c2, Auid:A.uid, Bid:B.uid, A:runForRect(A,a), B:runForRect(B,b) }
    : { kind:'v', gx:fixed, y1:c1, y2:c2, Auid:A.uid, Bid:B.uid, A:runForRect(A,a), B:runForRect(B,b) };
}

/* ===================== Composites (contiguity by shared edge) ===================== */
function rectsTouch(a,b){
  return ((a.x2 + 1 === b.x1 || b.x2 + 1 === a.x1) && !(a.y2 < b.y1 || b.y2 < a.y1)) ||
         ((a.y2 + 1 === b.y1 || b.y2 + 1 === a.y1) && !(a.x2 < b.x1 || b.x2 < a.x1));
}
function findContiguousGroups(){
  const groups = []; const done = new Set();
  for(const p of State.placements){
    if(done.has(p.uid)) continue;
    const group=[p]; const q=[p]; done.add(p.uid);
    while(q.length){
      const cur=q.shift(), rc=cur.rect(State.reg);
      for(const o of State.placements){
        if(done.has(o.uid)) continue;
        if(rectsTouch(rc, o.rect(State.reg))){ group.push(o); q.push(o); done.add(o.uid); }
      }
    }
    groups.push(group);
  }
  return groups;
}
function updateCompositeObjects(force=false){
  const sig = State.placements.map(p=>`${p.uid}:${p.vshift[0]},${p.vshift[1]}:${p.vertical}`).sort().join('|');
  if(!force && sig===State.lastPlacementSig) return;
  State.lastPlacementSig = sig;
  State.compositeObjects.clear();
  const groups = findContiguousGroups();
  let k=1;
  for(const g of groups){
    if(g.length<=1) continue;
    let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity;
    for(const p of g){ const r=p.rect(State.reg); minX=Math.min(minX,r.x1); minY=Math.min(minY,r.y1); maxX=Math.max(maxX,r.x2); maxY=Math.max(maxY,r.y2); }
    const id=`C${k}`; const name=generateCompositeName(); k++;
    State.compositeObjects.set(id,{id,name,group:g,bounds:{minX,minY,maxX,maxY},color:generateCompositeColor(id)});
  }
}
function generateCompositeColor(id){
  let hash=0; for(let i=0;i<id.length;i++){ hash=((hash<<5)-hash)+id.charCodeAt(i); hash|=0; }
  const hue = Math.abs(hash)%360, sat = 75, light = 50;
  return `hsl(${hue}, ${sat}%, ${light}%)`;
}

/* ===================== Hit Test & Interaction ===================== */
function pointInPlacement(px,py,p){
  const r = p.rect(State.reg), g=grid.g;
  const x0 = grid.cellLeft(r.x1), y0 = grid.cellTop(r.y1 + r.H - 1);
  return px>=x0 && px<=x0+r.W*g && py>=y0 && py<=y0+r.H*g;
}
function hitHandle(px,py,p){
  const r = p.rect(State.reg), g = grid.g;
  const x0 = grid.cellLeft(r.x1), y0 = grid.cellTop(r.y1 + r.H - 1);
  const rad = Math.max(4, Math.min(8, Math.floor(g*0.18))) + 2;
  // rotate first if non-square
  const [H,W] = p.usedDims(State.reg);
  if(H!==W){
    const rx = x0 + (r.W*g)/2;
    const ry = y0 - Math.min(18, Math.max(12, g*0.35));
    const d2 = (px-rx)*(px-rx)+(py-ry)*(py-ry);
    if(d2 <= Math.pow(Math.max(8, Math.min(12, Math.floor(g*0.25)))+4,2)) return 'rotate';
  }
  const pts = handlePoints(x0,y0,r.W,r.H,g);
  for(let i=0;i<pts.length;i++){ const [hx,hy]=pts[i]; const d2=(px-hx)*(px-hx)+(py-hy)*(py-hy); if(d2<=rad*rad) return i; }
  return -1;
}

// selection cycling for stacked hits
let lastClickTS = 0, lastClickPos = null, lastCandidates = [], cycleIdx = 0;
function hitTest(px,py){
  const c=[];
  for(let i=State.placements.length-1;i>=0;i--){
    const p=State.placements[i]; const r=p.rect(State.reg);
    const cx = grid.cellX(px), cy = grid.cellY(py);
    if(cx>=r.x1 && cx<=r.x2 && cy>=r.y1 && cy<=r.y2) c.push(p);
  }
  if(c.length===0){ cycleIdx=0; lastCandidates=[]; return null; }
  if(c.length===1){ cycleIdx=0; lastCandidates=c; return c[0].uid; }

  const now=Date.now(), repeat=(now-lastClickTS<500) && lastClickPos && Math.abs(px-lastClickPos.x)<10 && Math.abs(py-lastClickPos.y)<10 && c.length===lastCandidates.length && c.every((p,i)=>p.uid===lastCandidates[i].uid);
  cycleIdx = repeat ? (cycleIdx+1)%c.length : 0;
  lastClickTS=now; lastClickPos={x:px,y:py}; lastCandidates=[...c];
  return c[cycleIdx].uid;
}

/* pointer interaction */
let draggingMove = null;
canvas.addEventListener('pointermove', (e)=>{
  const rect = canvas.getBoundingClientRect(); const px=e.clientX-rect.left, py=e.clientY-rect.top;

  // drawing ghost
  if(byId('toolDraw').checked && State.drawDrag){
    State.drawDrag.y2 = grid.cellY(py); State.drawDrag.x2 = grid.cellX(px);
    const cand = ghostToRect(State.drawDrag);
    State.drawDrag.valid = !wouldOverlap(cand,null);
    scheduleDraw(); return;
  }

  // resizing
  if(State.resizeDrag && typeof State.resizeDrag.handle==='number'){
    const p = State.placements.find(q=>q.uid===State.resizeDrag.uid); if(!p) return;
    const s = State.resizeDrag.start;
    const cy = grid.cellY(py), cx = grid.cellX(px);
    let y1=s.y1, x1=s.x1, y2=s.y2, x2=s.x2;
    switch(State.resizeDrag.handle){
      case 0:y1=cy;x1=cx;break; case 1:y1=cy;break; case 2:y1=cy;x2=cx;break; case 3:x2=cx;break;
      case 4:y2=cy;x2=cx;break; case 5:y2=cy;break; case 6:y2=cy;x1=cx;break; case 7:x1=cx;break;
    }
    const ny1=Math.min(y1,y2), nx1=Math.min(x1,x2), ny2=Math.max(y1,y2), nx2=Math.max(x1,x2);
    const H=Math.max(1, ny2-ny1+1), W=Math.max(1, nx2-nx1+1);
    const cand = {y1:ny1,x1:nx1,y2:ny2,x2:nx2,H,W,dy:ny1,dx:nx1};
    if(!wouldOverlap(cand,p.uid)){ p.tempDims=[H,W]; p.vshift=[ny1,nx1]; updateRightPanel(); updateCompositeObjects(); scheduleDraw(); }
    else scheduleDraw();
    return;
  }

  // moving
  if(draggingMove){
    const p = State.placements.find(q=>q.uid===draggingMove.uid); if(!p) return;
    const dxPx = px - draggingMove.startPx, dyPx = py - draggingMove.startPy;
    const ddx = Math.round(dxPx / grid.g), ddy = Math.round(-dyPx / grid.g);
    const r0 = p.rect(State.reg);
    const cand = { y1:draggingMove.origShift[0] + ddy, x1:draggingMove.origShift[1] + ddx };
    cand.y2 = cand.y1 + r0.H - 1; cand.x2 = cand.x1 + r0.W - 1; cand.H=r0.H; cand.W=r0.W; cand.dy=cand.y1; cand.dx=cand.x1;
    if(!wouldOverlap(cand,p.uid)){ p.vshift=[cand.y1,cand.x1]; updateRightPanel(); updateCompositeObjects(); scheduleDraw(); }
    else scheduleDraw();
    return;
  }

  // hover/rotate
  const uid = hitTest(px,py); State.hovered = uid;
  let hoveringRotate = false;
  for(const p of State.placements){
    const [H,W] = p.usedDims(State.reg); if(H===W) continue;
    const h = hitHandle(px,py,p); if(h==='rotate'){ hoveringRotate = true; State.hovered = p.uid; break; }
  }
  State.hoveringRotate = hoveringRotate;
  canvas.style.cursor = hoveringRotate ? 'pointer' : 'default';
  byId('hoverLabel').textContent = uid ? uid : '—';
  scheduleDraw();
});

canvas.addEventListener('pointerdown', (e)=>{
  if(e.button!==0) return;
  const rect = canvas.getBoundingClientRect(); const px=e.clientX-rect.left, py=e.clientY-rect.top;

  if(byId('toolDraw').checked){
    State.tool="draw";
    const y = grid.cellY(py), x = grid.cellX(px);
    State.drawDrag = {y1:y, x1:x, y2:y, x2:x, valid:true}; return;
  } else State.tool="select";

  // rotation first
  for(const p of State.placements){
    const [H,W] = p.usedDims(State.reg); if(H===W) continue;
    const h = hitHandle(px,py,p);
    if(h==='rotate'){ State.selected = p.uid; attemptRotate(p); pushHistory(); updateRightPanel(); updateCompositeObjects(); scheduleDraw(); return; }
  }

  const uid = hitTest(px,py);
  if(uid){
    State.selected = uid;
    const p = State.placements.find(q=>q.uid===uid);
    const h = hitHandle(px,py,p);
    if(h>=0){ const r = p.rect(State.reg); State.resizeDrag = { uid, handle:h, start:{y1:r.y1,x1:r.x1,y2:r.y2,x2:r.x2} }; }
    else { draggingMove = { uid, startPx:px, startPy:py, origShift:[...p.vshift] }; }
    updateRightPanel(); scheduleDraw();
  }else{
    State.selected = null; updateRightPanel(); scheduleDraw();
  }
});
window.addEventListener('pointerup', ()=>{
  // commit draw
  if(State.drawDrag){
    const y1 = Math.min(State.drawDrag.y1, State.drawDrag.y2);
    const x1 = Math.min(State.drawDrag.x1, State.drawDrag.x2);
    const y2 = Math.max(State.drawDrag.y1, State.drawDrag.y2);
    const x2 = Math.max(State.drawDrag.x1, State.drawDrag.x2);
    const H=Math.max(1,y2-y1+1), W=Math.max(1,x2-x1+1);
    const cand = { y1, x1, y2, x2, H, W, dy:y1, dx:x1 };
    if(!wouldOverlap(cand,null)){
      const usedH=H, usedW=W; const canonH=Math.min(usedH,usedW), canonW=Math.max(usedH,usedW);
      const newId = State.reg._canonicalId(canonH, canonW);
      State.reg.add(new Atomic(newId, canonH, canonW));
      const vertical = usedH > usedW;
      const p = new Placement({baseId:newId, vshift:[y1,x1], vertical});
      State.placements.push(p); State.selected=p.uid; refreshPalette(); updateRightPanel(); pushHistory();
    }
    State.drawDrag=null; updateCompositeObjects(true); scheduleDraw();
  }
  // commit resize
  if(State.resizeDrag){
    const p = State.placements.find(q=>q.uid===State.resizeDrag.uid);
    if(p && p.tempDims){ const [H,W]=p.tempDims; const [dy,dx]=p.vshift; commitReshape(p,H,W,dy,dx); p.tempDims=null; pushHistory(); }
    State.resizeDrag=null; updateCompositeObjects(true); scheduleDraw();
  }
  if(draggingMove){ pushHistory(); updateCompositeObjects(true); scheduleDraw(); }
  draggingMove=null;
});

/* Keyboard */
window.addEventListener('keydown',(e)=>{
  if(e.key==='Delete' || e.key==='Backspace'){
    if(document.activeElement && ['INPUT','TEXTAREA'].includes(document.activeElement.tagName)) return;
    deleteSelected(); pushHistory();
  }
  if((e.key==='r'||e.key==='R') && State.selected){ toggleHat(); pushHistory(); }
  if(e.key==='Tab' && State.selected){ e.preventDefault(); cycleInstances(); }
  if(e.key===' ' && State.selected){ e.preventDefault(); cycleInstances(); }
  if(e.ctrlKey && e.key.toLowerCase()==='z'){ e.preventDefault(); undo(); }
  if(e.ctrlKey && e.key.toLowerCase()==='y'){ e.preventDefault(); redo(); }
});

function cycleInstances(){
  const sel = State.placements.find(p=>p.uid===State.selected); if(!sel) return;
  const same = State.placements.filter(p=>p.baseId===sel.baseId);
  if(same.length<=1) return;
  const idx = same.indexOf(sel), next = same[(idx+1)%same.length];
  State.selected = next.uid; updateRightPanel(); scheduleDraw();
}

/* ===================== Actions ===================== */
function ghostToRect(gd){
  const y1=Math.min(gd.y1,gd.y2), x1=Math.min(gd.x1,gd.x2), y2=Math.max(gd.y1,gd.y2), x2=Math.max(gd.x1,gd.x2);
  const H=Math.max(1, y2-y1+1), W=Math.max(1, x2-x1+1);
  return {y1,x1,y2,x2,H,W,dy:y1,dx:x1};
}
function attemptRotate(p){
  const r = p.rect(State.reg); const [H,W] = p.usedDims(State.reg);
  if(H===W) return;
  const nH=W, nW=H; const cand={ y1:r.y1,x1:r.x1,y2:r.y1+nH-1,x2:r.x1+nW-1,H:nH,W:nW,dy:r.y1,dx:r.x1 };
  if(!wouldOverlap(cand,p.uid)) p.vertical = !p.vertical;
}
function commitReshape(p, usedH, usedW, dy, dx){
  const applyAll = byId('applyAll').checked;
  const canonH=Math.min(usedH,usedW), canonW=Math.max(usedH,usedW);
  const vertical = usedH>usedW;
  const cand={y1:dy,x1:dx,y2:dy+usedH-1,x2:dx+usedW-1,H:usedH,W:usedW,dy,dx};
  if(wouldOverlap(cand,p.uid)) return;

  if(applyAll){
    State.reg.update(p.baseId, canonH, canonW);
    if(conflictForBase(p.baseId)){
      const newId = State.reg._canonicalId(canonH,canonW);
      State.reg.add(new Atomic(newId,canonH,canonW));
      p.baseId=newId; p.vertical=vertical; p.vshift=[dy,dx]; refreshPalette();
    }else{ p.vertical=vertical; p.vshift=[dy,dx]; }
  }else{
    const newId = State.reg._canonicalId(canonH,canonW);
    State.reg.add(new Atomic(newId,canonH,canonW));
    p.baseId=newId; p.vertical=vertical; p.vshift=[dy,dx]; refreshPalette();
  }
  updateRightPanel();
}
function conflictForBase(id){
  const group = State.placements.filter(p=>p.baseId===id);
  for(let i=0;i<group.length;i++) for(let j=i+1;j<group.length;j++) if(rectsOverlap(group[i].rect(State.reg), group[j].rect(State.reg))) return true;
  return false;
}
function deleteSelected(){
  if(!State.selected) return;
  State.placements = State.placements.filter(p=>p.uid!==State.selected);
  State.selected=null; updateRightPanel(); updateCompositeObjects(); scheduleDraw();
}

/* ===================== Palette & Scene UI ===================== */
function refreshPalette(){
  const list = byId('atomList'); list.innerHTML='';
  for(const a of State.reg.list()){
    const row = document.createElement('div'); row.className='item';
    row.innerHTML = `<div><strong>${a.id}</strong> <span class="muted">H×W=${a.H}×${a.W}</span></div>
                     <div><button class="ghost" data-id="${a.id}">Place</button></div>`;
    list.appendChild(row);
    row.querySelector('button').onclick = ()=> placeAtom(a.id);
  }
}
function placeAtom(id){
  const a = State.reg.get(id); const [Hc,Wc]=a.dims(); const usedH=Hc, usedW=Wc;
  let dy=1, dx=1, found=false;
  for(let row=1; row<200 && !found; row++){
    for(let col=1; col<200; col++){
      const cand={y1:row,x1:col,y2:row+usedH-1,x2:col+usedW-1,H:usedH,W:usedW};
      if(!wouldOverlap(cand,null)){ dy=row; dx=col; found=true; break; }
    }
  }
  const p = new Placement({baseId:id, vshift:[dy,dx], vertical:false});
  State.placements.push(p); State.selected=p.uid; updateRightPanel(); scheduleDraw(); pushHistory();
}

/* Grid controls */
byId('cellSize').oninput = ()=>{ grid.g = clamp(parseInt(byId('cellSize').value,10),16,96); scheduleDraw(); pushHistory(); };
byId('boldGrid').onchange = ()=>{ scheduleDraw(); pushHistory(); };

/* Right panel status */
function updateRightPanel(){
  const sel = State.placements.find(p=>p.uid===State.selected);
  byId('selBadge').textContent = sel ? sel.uid : '—';
  const selStatus = byId('selStatus');
  if(!sel){
    selStatus.textContent='No selection'; selStatus.className='status';
    byId('selLabel').textContent='—'; byId('selDims').textContent='—'; byId('selPos').textContent='—';
    byId('selCanon').textContent='—'; byId('selNotation').textContent='—';
  }else{
    selStatus.textContent='Shape selected'; selStatus.className='status ok';
    const r = sel.rect(State.reg); const a = State.reg.get(sel.baseId);
    byId('selLabel').textContent = `${sel.vertical?'^ ':''}${sel.baseId} [${sel.uid}]`;
    byId('selDims').textContent = `${r.H}×${r.W}`;
    byId('selPos').textContent = `${r.y1},${r.x1}`;
    byId('selCanon').textContent = `< ${a.id} | 1,1 ; ${a.H},${a.W} >`;
    const dims = (sel.vertical && a.H!==a.W) ? `${a.W},${a.H}` : `${a.H},${a.W}`;
    byId('selNotation').textContent = `< ${sel.vertical?'^ ':''}${a.id} | 1,1 ; ${dims} >`;
    byId('editH').value=r.H; byId('editW').value=r.W; byId('editDY').value=r.y1; byId('editDX').value=r.x1;
  }
  byId('countP').textContent=String(State.placements.length);
  byId('countC').textContent=String(totalCells());
}
function totalCells(){ let n=0; for(const p of State.placements){ const r=p.rect(State.reg); n += r.H*r.W; } return n; }

/* Contacts panel */
function updateContactPanel(){
  const wrap = byId('contactList'); wrap.innerHTML=""; let k=1;
  for(const c of State.contacts){
    const left  = `&lt; ${c.A.hat?'^ ':''}${c.A.id} | ( ${c.A.y1},${c.A.x1} ; ${c.A.y2},${c.A.x2} )${c.A.edge} &gt;`;
    const right = `&lt; ${c.B.hat?'^ ':''}${c.B.id} | ( ${c.B.y1},${c.B.x1} ; ${c.B.y2},${c.B.x2} )${c.B.edge} &gt;`;
    const join  = `&lt; C${k} | ${left} ${right} &gt;`;
    const div=document.createElement('div'); div.className='contactItem mono';
    div.innerHTML = `Contact ${k}:<br>${left}  ↔  ${right}<br><span class="muted">${join}</span>`;
    wrap.appendChild(div); k++;
  }
  if(State.contacts.length===0){ const none=document.createElement('div'); none.className='muted'; none.textContent='No contacting edges.'; wrap.appendChild(none); }
}

/* Selection actions (buttons) */
function toggleHat(){
  const sel = State.placements.find(p=>p.uid===State.selected); if(!sel) return;
  const [H,W] = sel.usedDims(State.reg); if(H===W) return;
  attemptRotate(sel); updateRightPanel(); scheduleDraw();
}
byId('toggleHat').onclick = ()=>{ toggleHat(); pushHistory(); };
byId('deleteSel').onclick = ()=>{ deleteSelected(); pushHistory(); };
byId('duplicate').onclick = ()=>{
  const sel = State.placements.find(p=>p.uid===State.selected); if(!sel) return;
  const r = sel.rect(State.reg);
  const offsets = [[0,r.W+1],[r.H+1,0],[0,-(r.W+1)],[-(r.H+1),0],[r.H+1,r.W+1]];
  let dy=r.y1, dx=r.x1+r.W+1;
  for(const [oy,ox] of offsets){
    const c={y1:r.y1+oy,x1:r.x1+ox,y2:r.y1+oy+r.H-1,x2:r.x1+ox+r.W-1,H:r.H,W:r.W};
    if(!wouldOverlap(c,null)){ dy=c.y1; dx=c.x1; break; }
  }
  const dup=new Placement({baseId:sel.baseId,vshift:[dy,dx],vertical:sel.vertical,color:nextColor()});
  if(!wouldOverlap(dup.rect(State.reg),null)){ State.placements.push(dup); State.selected=dup.uid; updateRightPanel(); updateCompositeObjects(true); scheduleDraw(); pushHistory(); }
};
byId('applyNumeric').onclick = ()=>{
  const sel = State.placements.find(p=>p.uid===State.selected); if(!sel) return;
  const H = Math.max(1, parseInt(byId('editH').value,10)||1);
  const W = Math.max(1, parseInt(byId('editW').value,10)||1);
  const dy = Math.round(parseFloat(byId('editDY').value)||1);
  const dx = Math.round(parseFloat(byId('editDX').value)||1);
  const cand = { y1:dy, x1:dx, y2:dy+H-1, x2:dx+W-1, H, W, dy, dx };
  if(!wouldOverlap(cand, sel.uid)){ commitReshape(sel,H,W,dy,dx); updateCompositeObjects(true); scheduleDraw(); pushHistory(); }
};
byId('detachNow').onclick = ()=>{
  const sel = State.placements.find(p=>p.uid===State.selected); if(!sel) return;
  const r=sel.rect(State.reg); commitReshape(sel,r.H,r.W,r.y1,r.x1); updateCompositeObjects(true); scheduleDraw(); pushHistory();
};

/* Z-order */
byId('bringFront').onclick=()=>{ if(!State.selected) return; const i=State.placements.findIndex(p=>p.uid===State.selected); if(i>=0){ const [p]=State.placements.splice(i,1); State.placements.push(p); scheduleDraw(); pushHistory(); } };
byId('sendBack').onclick =()=>{ if(!State.selected) return; const i=State.placements.findIndex(p=>p.uid===State.selected); if(i>=0){ const [p]=State.placements.splice(i,1); State.placements.unshift(p); scheduleDraw(); pushHistory(); } };

/* Undo/Redo buttons */
byId('undoBtn').onclick = ()=>undo();
byId('redoBtn').onclick = ()=>redo();

/* Copy helpers */
async function copyToClipboard(text){
  try{ await navigator.clipboard.writeText(text); }
  catch(_){ const ta=document.createElement('textarea'); ta.value=text; document.body.appendChild(ta); ta.select(); document.execCommand('copy'); document.body.removeChild(ta); }
}
function copyContacts(){
  if(State.contacts.length===0){ copyToClipboard('No contacts found.'); return; }
  let out=`Contacts (${State.contacts.length}):\n`; let k=1;
  for(const c of State.contacts){
    const left = `< ${c.A.hat?'^ ':''}${c.A.id} | ( ${c.A.y1},${c.A.x1} ; ${c.A.y2},${c.A.x2} )${c.A.edge} >`;
    const right= `< ${c.B.hat?'^ ':''}${c.B.id} | ( ${c.B.y1},${c.B.x1} ; ${c.B.y2},${c.B.x2} )${c.B.edge} >`;
    const join = `< C${k} | ${left} ${right} >`;
    out += `Contact ${k}: ${left} ↔ ${right}\n  ${join}\n\n`; k++;
  }
  copyToClipboard(out);
}
function copySelection(){
  const sel = State.placements.find(p=>p.uid===State.selected);
  if(!sel){ copyToClipboard('No selection.'); return; }
  const r = sel.rect(State.reg); const a=State.reg.get(sel.baseId);
  const dims = (sel.vertical && a.H!==a.W) ? `${a.W},${a.H}` : `${a.H},${a.W}`;
  let txt = `Selected Object: ${sel.uid}\nLabel: ${sel.vertical?'^ ':''}${sel.baseId} [${sel.uid}]\nDimensions: ${r.H}×${r.W}\nPosition: (${r.y1},${r.x1})\nCanonical: < ${a.id} | 1,1 ; ${a.H},${a.W} >\nNotation: < ${sel.vertical?'^ ':''}${a.id} | 1,1 ; ${dims} >`;
  copyToClipboard(txt);
}
function copyScene(){
  let out=`Scene Summary:\nPlacements: ${State.placements.length}\nOccupied cells: ${totalCells()}\nContacts: ${State.contacts.length}\n\n`;
  if(State.placements.length){
    out+='Objects:\n';
    for(const p of State.placements){
      const r=p.rect(State.reg); out += `  < ${p.vertical?'^ ':''}${State.reg.get(p.baseId).id} | ${r.y1},${r.x1} ; ${r.y2},${r.x2} >\n`;
    }
  }
  copyToClipboard(out);
}
function copyAllObjects(){
  if(!State.placements.length){ copyToClipboard('No objects in scene.'); return; }
  let out=`All Objects (${State.placements.length}):\n\n`;
  for(const p of State.placements){
    const r=p.rect(State.reg); out += `< ${p.vertical?'^ ':''}${State.reg.get(p.baseId).id} | ${r.y1},${r.x1} ; ${r.y2},${r.x2} >\n`;
  }
  copyToClipboard(out);
}
byId('copyContacts').onclick = copyContacts;
byId('copySelection').onclick = copySelection;
byId('copyScene').onclick = copyScene;
byId('copyAllObjects').onclick = copyAllObjects;
function copyConsolidation(){ const d = byId('consolidationStats'); copyToClipboard((d.textContent||'').trim()); }
byId('copyConsolidation').onclick = copyConsolidation;

/* Export SVG (gridline math) */
function escapeXml(s){ return s.replace(/[<>&'"]/g, c=>({ '<':'&lt;','>':'&gt;','&':'&amp;',"'":'&apos;','"':'&quot;' }[c])); }
function exportSVG(){
  const g = grid.g;

  // bounds (cells)
  let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity;
  for(const p of State.placements){ const r=p.rect(State.reg); minX=Math.min(minX,r.x1); minY=Math.min(minY,r.y1); maxX=Math.max(maxX,r.x2); maxY=Math.max(maxY,r.y2); }
  if(minX===Infinity){ minX=minY=1; maxX=maxY=10; }

  const pad=2;
  const svgW=(maxX-minX+1+2*pad)*g, svgH=(maxY-minY+1+2*pad)*g + 20;
  let svg=`<svg width="${svgW}" height="${svgH}" xmlns="http://www.w3.org/2000/svg">`;
  svg+=`<rect width="${svgW}" height="${svgH}" fill="#ffffff" stroke="#e2e8f0" stroke-width="1"/>`;
  svg+=`<defs><pattern id="grid" width="${g}" height="${g}" patternUnits="userSpaceOnUse"><path d="M ${g} 0 L 0 0 0 ${g}" fill="none" stroke="#f1f5f9" stroke-width="1"/></pattern></defs>`;
  svg+=`<rect width="${svgW}" height="${svgH}" fill="url(#grid)"/>`;

  // placements
  for(const p of State.placements){
    const r=p.rect(State.reg);
    const x=(r.x1-minX+pad)*g, y=( (maxY - (r.y1 + r.H - 1)) + pad )*g; // flip Y for SVG top-left
    const w=r.W*g, h=r.H*g;
    svg+=`<rect x="${x}" y="${y}" width="${w}" height="${h}" fill="${p.color}" stroke="#8ca2c0" stroke-width="1.5"/>`;
    const label=escapeXml(`${p.vertical?'^ ':''}${p.baseId}`);
    svg+=`<text x="${x+4}" y="${y+14}" font-family="ui-monospace, SFMono-Regular, Menlo, Consolas, Liberation Mono, monospace" font-size="12" fill="#0b1526">${label}</text>`;
    const notation = escapeXml(`< ${p.vertical?'^ ':''}${p.baseId} | ${r.y1},${r.x1} ; ${r.y2},${r.x2} >`);
    svg+=`<text x="${x}" y="${y+h+16}" font-family="ui-monospace, SFMono-Regular, Menlo, Consolas, Liberation Mono, monospace" font-size="10" fill="#64748b">${notation}</text>`;
  }

  // contacts (lines on gridlines)
  for(const c of State.contacts){
    if(c.kind==='h'){
      const y=( (maxY - c.gy) + pad )*g;
      const x1=(c.x1 - minX + pad - 1)*g;
      const x2=(c.x2 - minX + pad)*g;
      svg+=`<line x1="${x1}" y1="${y}" x2="${x2}" y2="${y}" stroke="#fb923c" stroke-width="3"/>`;
    }else{
      const x=( (c.gx - minX + pad) )*g;
      const y1=( (maxY - c.y2) + pad )*g;
      const y2=( (maxY - (c.y1 - 1)) + pad )*g;
      svg+=`<line x1="${x}" y1="${y1}" x2="${x}" y2="${y2}" stroke="#fb923c" stroke-width="3"/>`;
    }
  }
  svg+=`</svg>`;
  const blob = new Blob([svg], {type:'image/svg+xml'}); const url=URL.createObjectURL(blob); const a=document.createElement('a');
  a.href=url; a.download=`polyomino_${new Date().toISOString().slice(0,19).replace(/:/g,'-')}.svg`; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
}
byId('exportSVG').onclick = exportSVG;

/* Export Notation */
function generateCompositeFromGroup(group, compositeId, compositeName){
  if(group.length===1) return null;
  let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity;
  for (const p of group){ const r=p.rect(State.reg); minX=Math.min(minX,r.x1); minY=Math.min(minY,r.y1); maxX=Math.max(maxX,r.x2); maxY=Math.max(maxY,r.y2); }
  // Join form (pairwise from contacts among group)
  const joins=[];
  for(let i=0;i<group.length;i++){
    for(let j=i+1;j<group.length;j++){
      const A = group[i], B = group[j];
      const a = A.rect(State.reg), b = B.rect(State.reg);
      // horizontal adjacency
      if(a.y2 + 1 === b.y1){
        const x1 = Math.max(a.x1,b.x1), x2 = Math.min(a.x2,b.x2);
        if(x1<=x2){ const c = contactRecord(A,B,'h', a.y2, x1, x2);
          const left  = `< ${c.A.hat?'^ ':''}${c.A.id} | ( ${c.A.y1},${c.A.x1} ; ${c.A.y2},${c.A.x2} )${c.A.edge} >`;
          const right = `< ${c.B.hat?'^ ':''}${c.B.id} | ( ${c.B.y1},${c.B.x1} ; ${c.B.y2},${c.B.x2} )${c.B.edge} >`;
          joins.push(`${left} ${right}`);
        }
      }
      if(b.y2 + 1 === a.y1){
        const x1 = Math.max(a.x1,b.x1), x2 = Math.min(a.x2,b.x2);
        if(x1<=x2){ const c = contactRecord(A,B,'h', b.y2, x1, x2);
          const left  = `< ${c.A.hat?'^ ':''}${c.A.id} | ( ${c.A.y1},${c.A.x1} ; ${c.A.y2},${c.A.x2} )${c.A.edge} >`;
          const right = `< ${c.B.hat?'^ ':''}${c.B.id} | ( ${c.B.y1},${c.B.x1} ; ${c.B.y2},${c.B.x2} )${c.B.edge} >`;
          joins.push(`${left} ${right}`);
        }
      }
      // vertical adjacency
      if(a.x2 + 1 === b.x1){
        const y1 = Math.max(a.y1,b.y1), y2 = Math.min(a.y2,b.y2);
        if(y1<=y2){ const c = contactRecord(A,B,'v', a.x2, y1, y2);
          const left  = `< ${c.A.hat?'^ ':''}${c.A.id} | ( ${c.A.y1},${c.A.x1} ; ${c.A.y2},${c.A.x2} )${c.A.edge} >`;
          const right = `< ${c.B.hat?'^ ':''}${c.B.id} | ( ${c.B.y1},${c.B.x1} ; ${c.B.y2},${c.B.x2} )${c.B.edge} >`;
          joins.push(`${left} ${right}`);
        }
      }
      if(b.x2 + 1 === a.x1){
        const y1 = Math.max(a.y1,b.y1), y2 = Math.min(a.y2,b.y2);
        if(y1<=y2){ const c = contactRecord(A,B,'v', b.x2, y1, y2);
          const left  = `< ${c.A.hat?'^ ':''}${c.A.id} | ( ${c.A.y1},${c.A.x1} ; ${c.A.y2},${c.A.x2} )${c.A.edge} >`;
          const right = `< ${c.B.hat?'^ ':''}${c.B.id} | ( ${c.B.y1},${c.B.x1} ; ${c.B.y2},${c.B.x2} )${c.B.edge} >`;
          joins.push(`${left} ${right}`);
        }
      }
    }
  }
  const joiningForm = `< ${compositeId} | ${joins.join(' ; ')} >`;

  // Coordinate form (in group-bounds local coords)
  const blocks=[];
  for(const p of group){
    const r=p.rect(State.reg);
    const y1=r.y1-minY+1, x1=r.x1-minX+1, y2=r.y2-minY+1, x2=r.x2-minX+1;
    blocks.push(`{ ${y1},${x1} ; ${y2},${x2} }`);
  }
  blocks.sort();
  const coordinateForm = `< ${compositeId} | ${blocks.join(' ')} >`;

  return { id:compositeId, joiningForm, coordinateForm, group, bounds:{minX,minY,maxX,maxY} };
}
function generateNotation(){
  let out='';
  // 1. Atomic library used
  const used = new Set(State.placements.map(p=>p.baseId));
  out += '# Library of Atomic Objects Used\n';
  for(const id of used){ const a=State.reg.get(id); out += `< ${a.id} | 1,1 ; ${a.H},${a.W} >\n`; }
  out += '\n---\n\n';

  // 2. Composite library
  out += '# Library of Composite Objects Used\n# (Composite objects formed by attachments)\n\n';
  const groups=findContiguousGroups(); const composites=[];
  let c=1;
  for(const g of groups){
    if(g.length<=1) continue;
    const comp = generateCompositeFromGroup(g, `C${c}`, `S${c}`); c++;
    if(comp){ composites.push(comp); out += `# Composite Object ${comp.id} (${g.length} components)\n# Joining Operation Form:\n${comp.joiningForm}\n# Composite Coordinate Form:\n${comp.coordinateForm}\n\n`; }
  }
  if(!composites.length) out += '# No composite objects formed by attachments\n';
  out += '---\n\n';

  // 3. Instances on canvas
  out += '# Instances on Canvas\n';
  const placementToComp = new Map();
  for(const comp of composites) for(const p of comp.group) placementToComp.set(p.uid, comp.id);

  let i=1;
  for(const comp of composites){
    let minY=Infinity,minX=Infinity; for(const p of comp.group){ const r=p.rect(State.reg); minY=Math.min(minY,r.y1); minX=Math.min(minX,r.x1); }
    out += `< I${i++} @ ${comp.id} | { Ref - | Rot - } { ${minY},${minX} } >\n`;
  }
  for(const p of State.placements){
    if(placementToComp.has(p.uid)) continue;
    const r=p.rect(State.reg); const a=State.reg.get(p.baseId);
    const ops = (p.vertical && a.H!==a.W) ? '{ Ref - | Rot 1 }' : '{ Ref - | Rot - }';
    out += `< I${i++} @ ${p.baseId} | ${ops} { ${r.y1},${r.x1} } >\n`;
  }
  return out;
}
byId('exportNotation').onclick = ()=>{ computeContacts(); const txt=generateNotation(); const blob=new Blob([txt],{type:'text/plain'}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download=`polyomino_notation_${new Date().toISOString().slice(0,19).replace(/:/g,'-')}.txt`; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url); };

/* Import Notation */
byId('importNotation').onclick = ()=> byId('importFile').click();
byId('importFile').addEventListener('change', (e)=>{
  const file = e.target.files && e.target.files[0];
  if(!file) return;
  if(State.placements.length > 0){
    const ok = confirm('This will clear all current objects. Continue?');
    if(!ok){ e.target.value=''; return; }
  }
  const reader = new FileReader();
  reader.onload = ()=>{ importFromNotation(String(reader.result)); e.target.value=''; };
  reader.readAsText(file);
});
function parseNotationFile(content){
  const lines = content.split('\n');
  let section=''; const atomicObjects=new Map(), compositeObjects=new Map(), instances=[];
  for(const raw of lines){
    const line=raw.trim(); if(!line) continue;
    if(line.includes('Library of Atomic Objects Used')){ section='atomic'; continue; }
    if(line.includes('Library of Composite Objects Used')){ section='composite'; continue; }
    if(line.includes('Instances on Canvas')){ section='instances'; continue; }
    if(line.startsWith('#')) continue;

    if(section==='atomic'){
      const m = line.match(/< (\w+) \| 1,1 ; (\d+),(\d+) >/);
      if(m){ const [,id,h,w]=m; atomicObjects.set(id,{id,h:parseInt(h),w:parseInt(w)}); continue; }
      const alt = line.match(/< (\w+) \| (\d+),(\d+) ; (\d+),(\d+) >/);
      if(alt){ const [,id,y1,x1,y2,x2]=alt; const h=parseInt(y2)-parseInt(y1)+1, w=parseInt(x2)-parseInt(x1)+1; atomicObjects.set(id,{id,h,w}); }
    }
    if(section==='composite'){
      const m = line.match(/< (C\d+) \| (.+) >/);
      if(m){
        const [,id,coords] = m;
        const blocks = coords.match(/\{ \d+,\d+ ; \d+,\d+ \}/g) || [];
        compositeObjects.set(id,{id,coords:blocks});
      }
    }
    if(section==='instances'){
      const m = line.match(/< (\w+) @ (\w+) \| .* \{ (\d+),(\d+) \} >/);
      if(m){ const [,iid,oid,y,x]=m; instances.push({instanceId:iid, objectId:oid, y:parseInt(y), x:parseInt(x)}); }
    }
  }
  return { atomicObjects, compositeObjects, instances };
}
function clearScene(){
  State.placements=[]; State.selected=null; State.reg.clear(); State.compositeObjects.clear(); ID_CONSOLIDATION.reset();
  refreshPalette(); updateRightPanel(); scheduleDraw(); pushHistory();
}
function createPlacementFromInstance(instance, atomicObjects, compositeObjects){
  const {objectId,y,x} = instance;
  for(const [id, a] of atomicObjects) if(!State.reg.map.has(id)) State.reg.add(new Atomic(id,a.h,a.w));
  if(compositeObjects.has(objectId)){
    const comp = compositeObjects.get(objectId);
    for(const block of comp.coords){
      const m = block.match(/\{ (\d+),(\d+) ; (\d+),(\d+) \}/); if(!m) continue;
      const [,y1,x1,y2,x2] = m.map(Number);
      const h = y2 - y1 + 1, w = x2 - x1 + 1;
      let atomicId=null, vertical=false;
      for(const [id,a] of atomicObjects){ if(a.h===h && a.w===w){ atomicId=id; vertical=false; break; } if(a.h===w && a.w===h){ atomicId=id; vertical=true; break; } }
      if(!atomicId){ const nid = State.reg._canonicalId(Math.min(h,w), Math.max(h,w)); State.reg.add(new Atomic(nid,Math.min(h,w),Math.max(h,w))); atomicId=nid; vertical = h>w; }
      const placement = new Placement({baseId:atomicId, vshift:[y + y1 - 1, x + x1 - 1], vertical});
      if(!wouldOverlap(placement.rect(State.reg), null)){ State.placements.push(placement); }
    }
    return;
  }
  if(atomicObjects.has(objectId)){
    const a = atomicObjects.get(objectId);
    State.reg.add(new Atomic(objectId, a.h, a.w));
    const placement = new Placement({baseId:objectId, vshift:[y,x], vertical:false});
    if(!wouldOverlap(placement.rect(State.reg), null)) State.placements.push(placement);
  }
}
function importFromNotation(content){
  const {atomicObjects, compositeObjects, instances} = parseNotationFile(content);
  clearScene();
  for(const inst of instances) createPlacementFromInstance(inst, atomicObjects, compositeObjects);
  refreshPalette(); updateRightPanel(); updateCompositeObjects(true); scheduleDraw(); pushHistory();
}

/* Consolidation UI */
byId('consolidateIds').onclick = ()=>{
  const stats = ID_CONSOLIDATION.consolidateAll();
  const d = byId('consolidationStats');
  d.style.display='block';
  d.innerHTML = `
    <div class="muted">Consolidation complete:</div>
    <div>- Atomic objects cleaned: ${stats.atomicConsolidated}</div>
    <div>- Composite objects cleaned: ${stats.compositeConsolidated}</div>
    <div>- Instance IDs cleaned: ${stats.placementConsolidated}</div>`;
};
byId('resetConsolidation').onclick = ()=>{ ID_CONSOLIDATION.reset(); byId('consolidationStats').style.display='none'; refreshPalette(); updateRightPanel(); scheduleDraw(); pushHistory(); };

/* Scene buttons */
byId('resetScene').onclick = ()=>{ State.placements=[]; State.selected=null; updateRightPanel(); scheduleDraw(); pushHistory(); };
byId('fitView').onclick = ()=>{
  if(!State.placements.length) return;
  const p = State.placements[0], r=p.rect(State.reg);
  const cy = Math.max(1, Math.floor((grid.h/grid.g)/2) - Math.floor(r.H/2) + 1);
  const cx = Math.max(1, Math.floor((grid.w/grid.g)/2) - Math.floor(r.W/2) + 1);
  const cand={y1:cy,x1:cx,y2:cy+r.H-1,x2:cx+r.W-1,H:r.H,W:r.W};
  if(!wouldOverlap(cand,p.uid)){ p.vshift=[cy,cx]; } updateRightPanel(); scheduleDraw(); pushHistory();
};

/* Wire palette buttons */
byId('addAtom').onclick = ()=>{ try{
  const id = byId('atomId').value.trim(); const H=parseInt(byId('atomH').value,10); const W=parseInt(byId('atomW').value,10);
  const a = new Atomic(id,H,W); State.reg.add(a); refreshPalette(); scheduleDraw(); pushHistory();
}catch(err){ alert(err.message); } };
byId('placeFirst').onclick = ()=>{ const first = State.reg.list()[0]; if(!first){ alert('Add an atomic rectangle to the palette first.'); return; } placeAtom(first.id); };
byId('clearPalette').onclick = ()=>{ State.reg.clear(); refreshPalette(); scheduleDraw(); pushHistory(); };

/* Init */
resizeCanvas(); refreshPalette(); updateRightPanel(); scheduleDraw();
</script>
</body>
</html>
